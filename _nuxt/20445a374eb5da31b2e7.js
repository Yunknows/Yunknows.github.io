(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{154:function(t,n,e){t.exports=e.p+"img/0a8ad42.jpg"},155:function(t,n,e){var content=e(159);"string"==typeof content&&(content=[[t.i,content,""]]),content.locals&&(t.exports=content.locals);(0,e(25).default)("c747ee28",content,!0,{sourceMap:!1})},157:function(t,n,e){"use strict";e.r(n);var r={},o=(e(158),e(17)),component=Object(o.a)(r,(function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("div",{staticClass:"post-container",on:{mousewheel:t.getCurrentIndicator}},[r("div",{staticClass:"post"},[r("img",{staticClass:"post-image",attrs:{src:e(154)}}),t._v(" "),r("div",{staticClass:"post-title"},[r("p",{ref:"title",staticClass:"title"},[t._v("HTTP 완벽가이드, Proxy에 대하여")]),t._v(" "),t._m(0)]),t._v(" "),r("div",{staticClass:"content"},[r("p",{ref:"indicator1",staticClass:"sub-title"},[t._v("Proxy Server")]),t._v("\n        프록시 서버란 무엇일까? 프록시의 뜻을 살펴보면 [대리]의 의미를 가지고 있다. 이를 보면 어떤 과정이나 행동을 대신해 준다고 막연하게나마 생각해볼 수 있다. 좀 더 구체적으로 설명한다면 '클라이언트와 서버 사이에 위치하여 HTTP 메시지를 정리하는 중개인' 정도로 생각할 수 있다.\n        "),r("br"),r("br"),t._v("\n        그렇다면, 중개인이 왜 필요한 것일까? 당연하게도 여러 이점이 있기 때문이다. 가령 보안상의 이유라던가, 필터링 기능, 부하 경감을 위한 Load Balancing 기능, 속도 개선을 위한 캐시 기능 등 프록시를 사용하는 것에는 이처럼 다양한 이유가 있다. * HTTP 트래픽을 모니터링하고 수정할 수도 있음.\n        "),r("br"),r("br"),t._v("\n        이제 [HTTP 완벽 가이드]의 내용을 천천히 살피며 프록시에 대해 좀 더 깊이 알아보도록 하겠다.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator2",staticClass:"sub-title"},[t._v("웹 중개의 역할을 하는 프록시 서버")]),t._v("\n        프록시 서버는 클라이언트와 서버 사이에 위치하기 때문에 웹 서버인 동시에 웹 클라이언트이기도 하다. 요청을 서버로 보내기도 하고, 요청을 보내고 응답을 받기도 하므로 요청과 커넥션을 적절히 다루고 응답해야한다. 이에 프록시를 만든다면, HTTP 클라이언트와 HTTP 서버의 양쪽 규칙 모두를 주의 깊게 따라야 한다.\n        "),r("br"),r("br"),t._v("\n        이런 프록시 서버는 하나의 클라이언트가 독점적으로 사용할 수도 있고, 여러 클라이언트가 공유할 수도 있다. 하나의 클라이언트만을 위한 프록시를 [개인 프록시]라 부른다. 여러 클라이언트가 함께 사용하는 프록시는 [공용 프록시]라 부른다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("공용 프록시")]),t._v("\n        대부분의 프록시는 공용이며 공유된 프록시이다. 이러한 공용 프록시는 중앙 집중형 프록시로 관리하는 게 비용효율이 높다. 또한 사용자가 많기 때문에 공통된 요청에서 이득을 취할 수 있는 캐시 프록시로 사용하기 좋다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("개인 프록시")]),t._v("\n        개인 전용 프록시는 흔하지 않지만 꾸준히 사용되고 있다. 보통 클라이언트 컴퓨터에서 직접 실행되는 형태를 띄우고 있으며, ISP 서비스와 마찬가지로 브라우저의 기능을 확장하거나 성능을 개선하는 등으로 이용된다.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator3",staticClass:"sub-title"},[t._v("프록시와 게이트웨이의 차이점?")]),t._v("\n        프록시는 같은 프로토콜을 사용하는 둘 이상의 어플리케이션을 연결하고, 게이트웨이는 서로 다른 프로토콜을 사용하는 둘 이상을 연결한다. 게이트웨이는 클라이언트와 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 프로토콜 변환기처럼 작동한다. 하지만 실질적으로 프록시와 게이트웨이의 차이점은 모호하다. 브라우저와 서버는 다른 버전의 HTTP를 구현하기에 프록시는 때때로 약간의 프로토콜 변환을 한다. 또한 상용 프록시 서버는 SSL 보안 프로토콜, SOCKS 방화벽, FTP 접근 등을 지원하기 위해 게이트웨이 기능을 구현한다."),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator4",staticClass:"sub-title"},[t._v("프록시 활용 사례")]),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("1) 어린이 필터")]),t._v("\n        어린이들에게 교육 사이트를 제공하면서 동시에 성인 콘텐츠를 차단하는 필터링 프록시\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("2) 문서 접근 제어자")]),t._v("\n        프록시 서버는 많은 웹 서버와 리소스에 대한 단일한 접근 제어 전략을 구현한다. 다양하고 많은 수의 웹 서버들을 하나 하나 수시로 수정/갱신하는 것이 아니라 중앙 프록시 서버에서 접근제어를 하는 방식이다. 이는 대기업이나 분산된 관료 조직에서 유용하게 쓰인다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("3) 보안 방화벽")]),t._v("\n        프록시 서버는 서버로 들어오거나 나가는 프로토콜의 흐름을 네트워크의 한 지점에서 통제한다. 이는 바이러스를 제거하거나 트래픽을 세심히 살펴볼 수 있도록 한다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("4) 웹 캐시")]),t._v("\n        프록시 캐시는 인기 있는 리소스의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄인다. 이에 대한 예로 CDN(Content Delivery Server)을 들 수 있으며, 추후 CDN에 대해서도 다루어 보고자 한다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("5) 리버스 프록시")]),t._v("\n        리버스 프록시는 진짜 웹 서버 요청을 받지만 웹 서버와는 달리 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작한다. 이는 하나의 프록시로 다수의 서버 요청을 처리하고, 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용된다. 이러한 리버스 프록시는 Nginx, Apach와 같은 웹 서버들을 통해서도 사용가능하지 추후 실제 코드로 다루어 보고자 한다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("6) 트랜스코더")]),t._v("\n        프록시 서버는 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정할 수 있다. 이와 같이 데이터의 표현 방식을 자연스럽게 변환하는 것을 트랜스 코딩이라고 한다. 중개자에 의한 콘텐츠 변형. 예를 들어, GIF 이미지를 JPG로 변환할 수도 있고, 다른 언어로 문서를 변환하는 것도 가능하다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("7) 익명의 프록시")]),t._v("\n        익명화 프록시는 HTTP 통신에서 신원을 확인할 수 있는 특성들(IP, From 헤더, Referer 헤더, 쿠키 등)을 제거하여 개인정보 보호와 익명성 보장에 기여 함.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator5",staticClass:"sub-title"},[t._v("프록시 서버 배치에 따른 분류")]),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("1) Egress 프록시")]),t._v("\n        로컬 네트워크와 인터넷 사이를 오가는 트래픽을 제어하기 위해 프록시를 로컬 네트워크의 출구에 위치시킬 수 있음. 주로 방화벽, 인터넷 트래픽 성능 개선, 필터링의 역할을 수행한다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("2) ingress 프록시")]),t._v("\n        클라이언트로부터의 모든 요청을 종합적으로 처리하기 위해 프록시를 접근 지점에 위치시킬 수 있음. 주로 로드 밸런싱, 속도 개선 및 대역폭 비용 감소의 목적으로 사용된다\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("3) reverse proxy")]),t._v("\n        웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청할 수 있다. 또한 웹 서버에 보안 기능을 추가하거나 빠른 웹 서버 캐시를 느린 웹 서버의 앞에 놓음으로써 성능을 개선할 수도 있다. 이처럼 reverse proxy는 웹 서버 성능 개선 목적이 있다.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator6",staticClass:"sub-title"},[t._v("프록시의 요청 방법")]),t._v("\n        프록시 서버들은 원 서버에 가까운 프록시 서버를 부모로 두고 상항에 맞게 부모 프록시나 원 서버에 정적/동적인 요청을 전달할 수 있다. 동적인 요청이라 함은 프록시가 상황에 맞게 유동적으로 프록시 서버와 원 서버에 요청을 보내는 것이라 할 수 있다. 동적으로 부모를 선택하는 방법에는 다음과 같은 예가 있다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("부하균형")]),t._v("\n        자식 프록시는 부하를 분산하기 위해 현재 부모들의 작업량 수준에 근거하여 부모 프록시를 고른다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("지리적 인접성에 근거한 라우팅")]),t._v("\n        자식 프록시는 원 서버의 지역을 담당하는 부모를 선택할 수도 있다. 먼 거리에 있는 서버에 요청하는 것이 아니라 인접한 지역을 담당하는 원 서버에 요청을 보낸다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("프로토콜/타입 라우팅")]),t._v("\n        어떤 자식 프록시는 URI에 근거하여 다른 부모나 원 서버로 라우팅 할 수 있다.\n        "),r("br"),r("br"),t._v(" "),r("p",{staticClass:"emphasis"},[t._v("유료 서비스 가입자를 위한 라우팅")]),t._v("\n        웹 서비스 운영자가 빠른 서비스를 위해 추가 요금을 지불하였다면, 해당 URI는 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 되어 성능 개선되도록 할 수 있다.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator7",staticClass:"sub-title"},[t._v("프록시 요청의 미묘한 특징들")]),t._v("\n        클라이언트가 서버로 직접 요청할 경우에는 스킴/호스트/포트번호가 없는 부분 URI를 가진다. 하지만 클라이언트에서 프록시로의 요청은 완전한 URI를 갖는다. 프록시는 서버와 커넥션이 필요하기 때문에 완전한 URI가 필요하다. 가상 호스트의 경우도 마찬가지이다.\n        "),r("br"),r("br"),t._v("\n        프록시에서는 부분 URI도 지원해야 하는데, 이는 호스트 헤더를 기반으로 완전한 URI를 추출하거나, 과거 이력에서 참조하는데 어떤 방법으로도 완전한 URI를 찾지 못 한다면 클라이언트로 Error 메시지를 보낸다.\n        "),r("br"),r("br"),t._v(" "),r("p",{ref:"indicator8",staticClass:"sub-title"},[t._v("메시지 추적")]),t._v("\n        많은 기업들이 보안, 비용 절감, 성능 개선 등 다양한 이유로 프록시 서버를 이용하고 있다. 또한 성능 상의 이유로 세계 곳곳에 흩어져 있는 캐시 저장고에 콘텐츠를 복제해 두는 방식이 흔해지고 있다. 이처럼 프록시가 점점 더 흔해지면서, 프록시를 넘나드는 요청의 흐름을 추적하고 문제점을 찾아내는 것도 정말 필요한 일이 되고 있다. 따라서 Via 헤더를 이용하여 메시지 전달을 추적하고, 메시지 루프를 진단하는 것들이 행해지고 있다.\n        "),r("br"),r("br"),r("br"),r("br")])])])}),[function(){var t=this.$createElement,n=this._self._c||t;return n("span",{staticClass:"post-tag"},[n("a",{staticClass:"tag"},[this._v("http")]),this._v(" "),n("a",{staticClass:"tag"},[this._v("nginx")])])}],!1,null,null,null);n.default=component.exports},158:function(t,n,e){"use strict";var r=e(155);e.n(r).a},159:function(t,n,e){var r=e(24);(t.exports=r(!1)).push([t.i,".post-container{-webkit-box-pack:center;justify-content:space-evenly;padding:0 16px}.post,.post-container{width:100%;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center}.post{max-width:1080px;-webkit-box-pack:justify;justify-content:space-between;-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;margin-top:18px}.post-title{max-width:1080px;width:100%;margin-bottom:18px}.post-tag,.post-title{display:-webkit-box;display:flex}.post-tag{-webkit-box-align:center;align-items:center}.post-image{max-width:1080px;width:100%;height:240px;-o-object-fit:cover;object-fit:cover;margin:16px 0}.indicator{position:fixed;right:3em;font-size:12px}.indicator-list-wrapped{list-style:none;line-height:24px;margin-left:0}.indicator-list{cursor:pointer}.indicator-active,.indicator-list:hover{color:#42b983}@media (max-width:1600px){.indicator{display:none}}@media (max-width:1080px){.post-title{-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.post-tag{margin-top:9px}.post-image{height:120px}}",""])},160:function(t,n,e){var map={"./cicd/cdcd_01_docker.vue":171,"./http/http_01_proxy.vue":157,"./project/hackers.vue":162};function r(t){var n=o(t);return e(n)}function o(t){if(!e.o(map,t)){var n=new Error("Cannot find module '"+t+"'");throw n.code="MODULE_NOT_FOUND",n}return map[t]}r.keys=function(){return Object.keys(map)},r.resolve=o,t.exports=r,r.id=160},161:function(t,n,e){t.exports=e.p+"img/5b7898a.png"},162:function(t,n,e){"use strict";e.r(n);var r=e(17),component=Object(r.a)({},void 0,void 0,!1,null,null,null);n.default=component.exports},171:function(t,n,e){"use strict";e.r(n);var r=[function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("div",{staticClass:"content"},[r("p",{staticClass:"title"},[t._v("CI/CD에 대해서 배워보자")]),t._v("\n\n  처음 웹 개발을 시작해야겠다고 다짐을 하고, HTML/CSS, Vue.js, Node.js, MongoDB ... 배우면 배울수록 정말 새로운 것들이 끊임없이 나타났다. 그러다 지인이 CI/CD에 대해서 설명해주었는데, 놀라웠다. 수정부터 빌드, 배포까지 자동화하는 것이라니! 이러한 스택을 얼른 배워야겠다고 생각했고, 곧 바로 서칭을 시작했다.\n\n  "),r("dl",[r("dt",[t._v("CI(Continuos Integration)")]),t._v(" "),r("dd",[t._v("개발자들이 각각 개발한 소스코드들을 특정 시점에 통합하는 것이 아니라, 주기적으로 통합하고 빌드하면서 통합과정에서 발생하는 오류들을 사전에 해결하고자 하는 방법이다.")])]),t._v(" "),r("dl",[r("dt",[t._v("CD(Continuos Delivery/Deployment)")]),t._v(" "),r("dd",[t._v("개발 중인 소프트웨어를 짧은 주기로 배포하고, 그 과정을 자동화하는 것이다.\n      ")])]),t._v("\n\n  CI의 개념은 이해가 가나, CD에 대해 찾아보니, 'Continuos Delivery'와 'Continuos Deployment'라는 두 개의 개념이 나왔다. 통상 CI/CD라 하면, 지속적 Integration/Delivery/Deployment를 의미하긴 하지만 그 차이점을 찾아보고 싶었다.\n\n  'Continuos Delivery'란, 지속적인 서비스 제공을 의미한다.\n  - 어플리케이션에 적용될 변경사항이 Repository에 자동으로 Delivery\n  - 운영팀은 해당 Repository를 실시간으로 프로덕션 환경으로 배포 가능\n\n  'Continuos Deployment'란, 지속적인 배포를 의미한다.\n  - 어플리케이션을 프로덕션 환경으로 배포하는 작업을 자동화하는 것\n  - 서버가 여러 대일 경우 중요하게 쓰임\n\n  "),r("img",{attrs:{src:e(161)}}),t._v("\n\n  즉, Delivery는 변경사항이 자동 적용되나 프로덕션 환경에는 수동으로 배포하는 것이고,\n  Deployment는 프로덕션에 배포하는 것까지! 자동화하는 것이었다.\n\n  이제, CI/CD에 대해서 이해하였으니 직접 부딪혀가며 경험해보고자 한다. 작업은 젠킨스 서버를 Docker에 띄워 진행해 보고자 한다.\n\n  ---\n\n  참고자료\n  >https://dzone.com/articles/continuous-delivery-vs-continuous-deployment-an-ov\n  >https://www.redhat.com/ko/topics/devops/what-is-ci-cd\n\n  "),r("div",[r("img",{staticClass:"profile"}),t._v(" "),r("span",{staticClass:"writer"},[t._v("Yunknows")]),t._v(" "),r("span",{staticClass:"date"},[t._v("2019/12/14, 17:00")])])])}],o={},c=e(17),component=Object(c.a)(o,(function(){var t=this.$createElement;this._self._c;return this._m(0)}),r,!1,null,null,null);n.default=component.exports},173:function(t,n,e){"use strict";e.r(n);e(68);var r=e(1),o=(e(157),e(160)("./"+window.location.pathname.replace("/blog/","").replace("&","/")+".vue"));r.a.component("postFile",o.default);var c={},l=e(17),component=Object(l.a)(c,(function(){var t=this.$createElement,n=this._self._c||t;return n("div",[n("post-file")],1)}),[],!1,null,null,null);n.default=component.exports}}]);